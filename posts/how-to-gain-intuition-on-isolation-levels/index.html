<!doctype html><html><body><a href=/>Kolosov Ivan</a><div id=content><h2>How to gain intutition on isolation levels</h2>2022-08-110<nav id=TableOfContents><ul><li><a href=#a-quick-recap-of-what-i-learned>A quick recap of what I learned</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><p>I was preparing to interview a candidate for a software engineering position today. The hypocrite that I am, I decided to ask them some tricky questions about databases, isolation levels in particular. So I decided to refresh my memory on this topic and here&rsquo;s the steps that I took:</p><ul><li>Revisited the relevant sections of Martin Kleppman&rsquo;s &ldquo;Designing Data-Intensive Applications&rdquo;, namely &ldquo;Weak isolation levels&rdquo; in chapter 7 (<a href=https://dataintensive.net>link to the book</a>);</li><li>Skimmed through PostgreSQL documentation on <a href=https://www.postgresql.org/docs/14/transaction-iso.html>isolation levels</a>;</li><li>And most importantly read through a brilliant post by Justin Jaffray (<a href=https://justinjaffray.com/what-does-write-skew-look-like/>&ldquo;What Does Write Skew Look Like?&rdquo;</a>). This cleared up some of the confusion left after reading the first two items in the list.</li></ul><p>I found that this list, while arguably pretty short and easily digestable, allowed me to get up to speed pretty quickly, hence the name of this blog post (I hope it doesn&rsquo;t sound too cocky!)</p><h2 id=a-quick-recap-of-what-i-learned>A quick recap of what I learned</h2><p>A transaction is a loaded term, but we can say with pretty much no loss of generality that it&rsquo;s a sequence of reads & writes executed atomically. Transaction isolation levels deal with how &ldquo;well&rdquo; transactions are isolated from each other.</p><p>When transactions are not isolated &ldquo;well enough&rdquo;, anomalies occur. E.g. a transaction can read a write by another transaction that&rsquo;s not yet committed. This is called a <em>dirty read</em>; PostgreSQL&rsquo;s default (and lowest) isolation level, <code>READ COMMITED</code>, prevents this anomaly.</p><p>Higher isolation levels prevent subtler kinds of anomalies. Snapshot isolation, known as <code>REPEATABLE READ</code> in PostgreSQL, prevents the <em>phantom read</em> anomaly in which a transaction reads from the same location and gets different results each time because of the writes committed by other transactions. This anomaly is also called <em>read skew</em> and is not prevented by <code>READ COMMITTED</code>.</p><p>Snapshot isolation prevents two transactions from concurrently writing to the same location, but it doesn&rsquo;t prevent a transaction from overwriting a location that was previously read by another transaction. This doesn&rsquo;t seem to be a big deal but leads to <em>write skew</em> anomalies. A good example of write skew is two transactions that both check if a meeting room is available and if so, create a meeting. Under snapshot isolation, both transactions can book the same room since they don&rsquo;t write to the same location.</p><p>Write skew is prevented by serializable isolation. A set of concurrent transactions is serializable if the result of their execution is the same as if they were executed serially in some order (hence the name). The good side effect of this is that if each transaction enforces some constraint (e.g. creates a meeting room only if it&rsquo;s available), then the constraint will hold at all times, no matter which other concurrent transactions are there.</p><p>Following the definition of serializable isolation, we can verify serializability of a given history of transactions by looking at a graph of dependencies between them and checking that this graph has no cycles. If it has no cycles, then any pair of transactions has a <em>happens before</em> relationship, therefore the result of their execution corresponds to some serial execution, even if in fact some or all of the transactions were concurrent.</p><p>Verifying serializability this way is expensive, but there&rsquo;s a <a href=https://www.cse.iitb.ac.in/infolab/Data/Courses/CS632/2009/Papers/p492-fekete.pdf>cool paper</a> (<em>Fekete A, Liarokapis D, O’Neil E, O’Neil P, Shasha D. Making snapshot isolation serializable.</em>) that gives a necessary condition of serializability which is true under snapshot isolation. Since this is a necessary condition rather than a criterion, using it will yield false positives, i.e. throw away some transaction histories which are in fact serializable, but in practice it&rsquo;s still cheap enough. Serializability verification algorithm based on this condition is called Serializable Snapshot Isolation (SSI).</p><p>And the coolest thing that I learned is that the Serializable Snapshot Isolation algorithm is actually a pretty recent result published in 2005 and is the algorithm used for implementing the <code>SERIALIZABLE</code> isolation level in PostgreSQL. And in fact PostgreSQL didn&rsquo;t have true serializability before this paper, more precisely, the <code>SERIALIZABLE</code> isolation level arrived in 2011 with PostgreSQL 9.1.0 (see release notes <a href=https://www.postgresql.org/docs/release/9.1.0/>here</a>).</p><h2 id=conclusion>Conclusion</h2><p>I&rsquo;m very excited about learning all these things. Also I now have a bunch of links to give to people who want to learn more about isolation levels. I also look forward to reading about the particulars of implementing Serializable Snapshot Isolation in PostgreSQL (here&rsquo;s the <a href=https://arxiv.org/abs/1208.4179>paper</a>).</p><ul></ul></div>Power by <a href=https://gohugo.io>Hugo</a> /
Theme <a href=https://github.com/J-Siu/hugo-theme-sk1/>SK1</a> by <a href=https://github.com/J-Siu/>J-Siu</a></body></html>