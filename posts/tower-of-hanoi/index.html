<!doctype html><html><body><a href=/>Kolosov Ivan</a>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><div id=content><h2>Tower of Hanoi</h2>2023-01-90<nav id=TableOfContents><ul><li><a href=#problem-statement>Problem statement</a></li><li><a href=#observations-aka-insights>Observations (a.k.a. insights)</a><ul><li><a href=#obs1>Observation 1: Stacks are interchangeable</a></li><li><a href=#obs2>Observation 2: There&rsquo;s a &ldquo;pivot arrangement&rdquo; any solution must neccessarily come to</a></li><li><a href=#obs3>Observation 3: Reaching pivot arrangement in a minimal number of moves leads to an optimal solution</a></li></ul></li><li><a href=#putting-it-all-together>Putting it all together</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav><p>It&rsquo;s rare that I manage to solve an algorithmic problem in a structured way. Usually I either come up with a solution quickly because I&rsquo;ve already solved a similar problem or I get stuck for a long time, drawing lots of example inputs on paper until I see a pattern. Recently I was able to solve a problem properly, by coming up with observations and then deriving the solution from these. Coming up with these observations, or insights, is particularly hard for me, so doing it satisfies me a lot. I&rsquo;m sharing the solution here to share this satisfaction and maybe even help someone become a better algorithmic thinker by seeing how a problem could be solved.</p><h2 id=problem-statement>Problem statement</h2><p>The problem I want to talk about is called Towers of Hanoi. It&rsquo;s so well known that it even has its own <a href=https://en.wikipedia.org/wiki/Tower_of_Hanoi>Wikipedia page</a>. I will use the statement from the <a href=https://cses.fi/problemset/task/2165/>CSES Problem Set</a>. In short, there are <code>n</code> round disks of sizes <code>n, n-1, ..., 1</code>. They form three stacks, left, middle and right. A disk cannot be placed on top of a larger disk and we can only move a disk if it&rsquo;s on top of a stack. Initally, all the disks are in the left stack. Our goal is to move all the disks to the right stack using the minimum number of moves. The solution must print the number of moves, then print each move.</p><p>For brevity, let&rsquo;s use the following notation:</p><ul><li>Let <code>L</code>, <code>M</code>, <code>R</code> be the left, middle and right stacks, respectively</li><li>Let <code>k</code> be the disk with size <code>k</code>. So in a problem that involves <code>n</code> disks, we will have disks <code>n, n-1, ..., 1</code>.</li></ul><p>So how do we approach this problem? From the statement, it&rsquo;s obvious that we cannot move disks arbitrarily, which naturally constrains the solution space. As we look closely at the problem statement, we can generate observations about which solutions are possible, which solutions are not, which solutions are minimal etc and then put these observations together.</p><h2 id=observations-aka-insights>Observations (a.k.a. insights)</h2><h3 id=obs1>Observation 1: Stacks are interchangeable</h3><p>Our goal is to move all disks from <code>L</code> to <code>R</code>. But if we have a solution for this problem, we also have a solution for moving all disks from <code>L</code> to <code>M</code> or, more generally, from any stack A to any other stack B, given that initially all disks reside on stack A.</p><h3 id=obs2>Observation 2: There&rsquo;s a &ldquo;pivot arrangement&rdquo; any solution must neccessarily come to</h3><p>In the target arrangement all disks, starting with disk <code>n</code>, are on <code>R</code> stack. Since at some point we must place disk <code>n</code> at the bottom of stack <code>R</code> and we cannot place a disk on top of a smaller disk, we necessarily must come to the following arrangement:</p><ul><li>stack <code>R</code> is empty</li><li>disks <code>n-1, n-2, ..., 1</code> are on top of some stack, say stack <code>M</code></li><li>disk <code>n</code> is the single disk in the remaining stack, say stack <code>L</code></li></ul><p>Let&rsquo;s call it a &ldquo;pivot arrangement&rdquo;.</p><p>Since stacks are interchangeable by <a href=#obs1>Observation 1</a>, we can choose that in the pivot arrangement <code>n</code> is going to be in the <code>L</code> stack without loss of generality.</p><h3 id=obs3>Observation 3: Reaching pivot arrangement in a minimal number of moves leads to an optimal solution</h3><p>Let&rsquo;s say we reached the pivot arrangement: disks <code>n-1, ..., 1</code> are on stack <code>M</code>, disk <code>n</code> is on stack <code>L</code>. If we move <code>n</code> to <code>R</code> we arrive at pretty much the same arrangement, but instead of stack <code>L</code> disk <code>n</code> is on stack <code>R</code>. Essentially we moved <code>n-1</code> smallest disks from their intial location on stack <code>L</code> to stack <code>M</code>. If we move disk <code>n</code> to <code>R</code>, then, by <a href=#obs1>Observation 1</a>, we can use the same moves to move <code>n - 1</code> smallest disks to stack <code>R</code> from their location on stack <code>M</code> with the only change that in the moves, we will use <code>M</code> instead of <code>R</code> and vice versa. We can&rsquo;t make illegal moves in the process because the only disk that&rsquo;s on stack <code>R</code> in the beginning is disk <code>n</code>, the largest one, and any other disk can be placed on top of it. After doing this, we get to the target arrangement.</p><p>If we can get to the pivot arrangement in the minimum possible number of moves, then the solution we get with this tactic is also minimal because, by <a href=#obs2>Observation 2</a>, we must arrive at pivot arrangement, so there are no better solutions than this one. To get to the pivot arrangement, we must move disks <code>n-1, ..., 1</code> from their initial location on stack <code>L</code> to stack <code>M</code>. By <a href=#obs1>Observation 1</a>, this is the same as being able to solve the original problem for <code>n - 1</code> disks. This means that the optimal solution can be constructed recursively.</p><h2 id=putting-it-all-together>Putting it all together</h2><p>For <code>n = 1</code>, the optimal solution is just moving the single disk from <code>L</code> to <code>R</code> which takes one move.</p><p>Suppose that we can construct an optimal solution for <code>n - 1</code>. Then, by <a href=#obs3>Observation 3</a>, we can use it to get to the pivot arrangement of <code>n</code> disks, then move disk <code>n</code> to the <code>R</code> stack, then use the same solution with different stack to get to the target arrangement. A straightforward way to implement this is to use a &ldquo;stack mapping&rdquo; that says which stack plays the role of <code>L</code>, <code>M</code> and <code>R</code> respectively in each recursive call. This mapping is passed as an argument to each recursive call and its value in the initial call is <code>L, M, R</code> which reflects the original goal of moving all disks from <code>L</code> to <code>R</code>.</p><p>The problem also asks us to calculate and print the number of moves. Since the algorithm makes exactly one move and two recursive calls in each call, then its recursion tree is a complete binary tree with n levels, where each node is one move. Therefore, the minimum number of moves made is $\sum_{k = 1}^{n} 2^{k - 1} = 2^n - 1$. This number can be calculated by using the binary shift operator to quickly compute the nth power of 2.</p><p>This leads to the following code:</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span>#include</span> <span>&lt;array&gt;</span><span>
</span></span></span><span style=display:flex><span><span>#include</span> <span>&lt;iostream&gt;</span><span>
</span></span></span><span style=display:flex><span><span>#include</span> <span>&lt;istream&gt;</span><span>
</span></span></span><span style=display:flex><span><span>#include</span> <span>&lt;ostream&gt;</span><span>
</span></span></span><span style=display:flex><span><span></span>
</span></span><span style=display:flex><span><span style=font-weight:700>static</span> <span style=font-weight:700>constexpr</span> <span>int</span> kL = 1;
</span></span><span style=display:flex><span><span style=font-weight:700>static</span> <span style=font-weight:700>constexpr</span> <span>int</span> kM = 2;
</span></span><span style=display:flex><span><span style=font-weight:700>static</span> <span style=font-weight:700>constexpr</span> <span>int</span> kR = 3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span>void</span> solve(std::ostream &amp;out, std::array&lt;<span>int</span>, 3&gt; map, <span>int</span> n) {
</span></span><span style=display:flex><span>  <span style=font-weight:700>if</span> (n == 0) {
</span></span><span style=display:flex><span>    <span style=font-weight:700>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  solve(out, {map[kL - 1], map[kR - 1], map[kM - 1]}, n - 1);
</span></span><span style=display:flex><span>  out &lt;&lt; map[kL - 1] &lt;&lt; <span style=font-style:italic>&#39; &#39;</span> &lt;&lt; map[kR - 1] &lt;&lt; <span style=font-style:italic>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>  solve(out, {map[kM - 1], map[kL - 1], map[kR - 1]}, n - 1);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span>void</span> Solve(std::istream &amp;in, std::ostream &amp;out) {
</span></span><span style=display:flex><span>  <span>int</span> n;
</span></span><span style=display:flex><span>  in &gt;&gt; n;
</span></span><span style=display:flex><span>  out &lt;&lt; ((1 &lt;&lt; n) - 1) &lt;&lt; <span style=font-style:italic>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>  solve(out, {kL, kM, kR}, n);
</span></span><span style=display:flex><span>}</span></span></code></pre></td></tr></table></div></div><p><code>Solve</code> is the entry point to the solution and <code>solve</code> is the recursive function that does all the work. The base of recursion is <code>n = 0</code>, in this case no moves are necessary since all 0 disks are already on stack <code>R</code>. Otherwise, we move <code>n - 1</code> disks from stack <code>L</code> to stack <code>R</code> with the first recursive call on line 14, then &ldquo;flip&rdquo; the pivot arrangement by moving disk <code>n</code> from stack <code>L</code> to stack <code>R</code>, then move the remaining <code>n - 1</code> disks from stack <code>M</code> to stack <code>R</code> with the second recursive call on line 16.</p><h2 id=conclusion>Conclusion</h2><p>Let&rsquo;s go through the process again. Key insights that enabled us to solve the problem were:</p><ul><li>stacks are interchangeable, i.e. solutions can be reused</li><li>there&rsquo;s a pivot arrangement each solution must come to</li><li>if we know how to solve the problem for n - 1 disks, we can reuse this solution for n disks</li></ul><p>Using these insights lets us solve the problem cleanly and prove that the solution is indeed minimal.</p><ul></ul>Prev <a href=/posts/how-to-gain-intuition-on-isolation-levels/>How to gain intutition on isolation levels</a></div>Power by <a href=https://gohugo.io>Hugo</a> /
Theme <a href=https://github.com/J-Siu/hugo-theme-sk1/>SK1</a> by <a href=https://github.com/J-Siu/>J-Siu</a></body></html>